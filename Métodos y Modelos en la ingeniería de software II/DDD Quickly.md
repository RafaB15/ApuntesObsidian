# What is Domain-Driven Design?

- We must understand from the beginning that software is originated from and deeply related to this domain.
- We canâ€™t just sit down and type code. We can do that, and it works well for trivial cases. But we cannot create complex software like that.
- In order to create good software, you have to know what that software is all about.
- One must understand the *domain* of what he is building software for.
- The entire purpose of the software is to enhance a specific domain. To be able to do that, the software has to fit harmoniously with the domain it has been created for.
- Software has to model the domain.
- Software which does not have its roots planted deeply into the domain will not react well to change over time.
- We need to create an abstraction of the domain. It is a model, **a model of the domain**.
- The model is our internal representation of the target domain, and it is very necessary throughout the design and the development process.
- Domain Driven Design combines design and development practice, and shows how design and development can work together to create a better solution. 
- Good design will accelerate the development, while feedback coming from the development process will enhance the design.

# The Ubiquitous Language

- The developer and the domain expert need to communicate and understand each other somehow.
- We must communicate to exchange ideas about the model, about the elements involved in the model, how we connect them, what is relevant and what is not.
- A core principle of domain-driven design is to use a language based on the model.
- Use the model as the backbone of a language. Request that the team use the language consistently in all communications, and also in the code.  While sharing knowledge and hammering out the model, the team uses speech, writing and diagrams. Make sure this language appears consistently in all the communication forms used by the team; for this reason, the language is called the **Ubiquitous Language**.